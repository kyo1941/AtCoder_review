## C - [Rotatable Array](https://atcoder.jp/contests/abc410/tasks/abc410_c)

- 配列の先頭から末尾に移動する操作(`pop_front`＆`push_back`)を大きい回数を行う問題
- `deque`でやればいいと思ったが操作回数の多さに断念
- `offset`を使用して参照を開始する先頭地点を移動させることで，実質的に操作を行えているのと同等
    - 常に先頭を末尾に移動しているため，配列の順番は失われないことが重要

## D - [XOR Shortest Walk](https://atcoder.jp/contests/abc410/tasks/abc410_d)

- グラフのウォークにおける合計XOR値の最小値を求める問題
- 同じ辺を使う回数が偶奇で仕分ければよいので，「同じ辺を2回以下のみ使用する」という条件でDFSしたがTLE
    - サイクルを含む分岐が多数存在する(サイクルのなかにサイクルが含まれているネスト構造のようなものなど)
- 単調増加/減少でないような累積値を求める際には，**状態DP**（もしくは**メモ化DFS**）が有効
    - ある地点における値が探索されたかどうかの`checked`を管理しておく（`checked[頂点][その地点までの値(重み)]`）
    - こうすればある頂点に対して同じ値を持っている(XORが偶数回使われたときなど)のケースを重複して探索しない

- 有効となるようなケース
    - **単調増加/減少でないような累積値を求める**(再掲)
    1. XOR和
    2. MOD演算
    3. bitDP
    4. パス上の属性の組み合わせ（例：これまでに通った辺の色(赤，青)の組み合わせなど）

## E - [Battles in a Row](https://atcoder.jp/contests/abc410/tasks/abc410_e)

- 2変数を独立で使用するグラフで適切に割り当てて最大の個数だけ進める問題<br>
ナップサック問題を応用するような考え方が有効
    - 重み(もしくは価値)を固定して，それがある値をとる(もしくはそれ以下/以上)条件で片方の変数を更新する
    - 今回はあるモンスターで使用する魔力を固定してその条件下で「体力をどれだけ最大化できるか」という問題を解けばいい
- 2変数が独立して動くような問題に対して，片方を固定してDPするのは基本的で重要な考え方